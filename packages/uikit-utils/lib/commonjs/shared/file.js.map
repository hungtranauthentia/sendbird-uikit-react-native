{"version":3,"names":["EXTENSION_MIME_MAP","imageExtRegex","exports","audioExtRegex","videoExtRegex","getFileType","extensionOrType","lowerCased","toLowerCase","indexOf","type","split","match","startsWith","getDownscaleSize","origin","resizing","ratio","maxWidth","width","maxHeight","height","Math","min","normalizeFileName","fileName","extension","_extension","_filename","hasExtension","lastIndexOf","length","parseMimeType","mimeType","fullType","parts","subtype","parameters","part","name","value","trim","getFileExtensionFromMime","MIME_EXTENSION_MAP","Object","entries","reduce","acc","_ref","key","getMimeFromFileExtension","ext","sliceIdx","extWithoutDot","slice","getFileExtension","filePath","pathWithoutParams","idx","result","getFileExtensionFromUri","uri","fetch","then","response","headers","get","isImage","shouldCompressImage","mime","compressionEnabled","arguments","undefined","isJPG","Boolean"],"sources":["file.ts"],"sourcesContent":["const EXTENSION_MIME_MAP = {\n  // Image\n  'jpeg': 'image/jpeg',\n  'jpg': 'image/jpeg',\n  'png': 'image/png',\n  'gif': 'image/gif',\n  'webp': 'image/webp',\n  'svg': 'image/svg+xml',\n\n  // Video\n  '3gp': 'video/3gpp',\n  'mp4': 'video/mp4',\n  'mpeg': 'video/mpeg',\n  'ogv': 'video/ogg',\n  'video/quicktime': 'mov',\n  'webm': 'video/webm',\n  'avi': 'video/x-msvideo',\n\n  // Audio\n  'aac': 'audio/aac',\n  'm4a': 'audio/m4a',\n  'mid': 'audio/midi',\n  'mp3': 'audio/mpeg',\n  'ogg': 'audio/ogg',\n  'wav': 'audio/wav',\n  'weba': 'audio/webm',\n\n  // Files\n  'txt': 'text/plain',\n  'pdf': 'application/pdf',\n  'doc': 'application/msword',\n  'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  'xls': 'application/vnd.ms-excel',\n  'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  'ppt': 'application/vnd.ms-powerpoint',\n  'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n  'zip': 'application/zip',\n  'json': 'application/json',\n  'gzip': 'application/x-gzip',\n} as Record<string, string>;\n\nexport const imageExtRegex = /jpeg|jpg|png|webp|gif/i;\nexport const audioExtRegex = /3gp|aac|aax|act|aiff|flac|gsm|m4a|m4b|m4p|tta|wma|mp3|webm|wav|ogg/i;\nexport const videoExtRegex = /mov|vod|mp4|avi|mpeg|ogv/i;\nexport const getFileType = (extensionOrType: string) => {\n  const lowerCased = extensionOrType.toLowerCase();\n\n  // mime type\n  if (lowerCased.indexOf('/') > -1) {\n    const type = lowerCased.split('/')[0];\n    if (type === 'video') return 'video';\n    if (type === 'audio') return 'audio';\n    if (type === 'image') return 'image';\n    return 'file';\n  }\n\n  // extensions\n  if (lowerCased.match(imageExtRegex)) return 'image';\n  if (lowerCased.match(audioExtRegex)) return 'audio';\n  if (lowerCased.match(videoExtRegex)) return 'video';\n\n  // others\n  if (lowerCased.startsWith('image')) return 'image';\n  if (lowerCased.startsWith('audio')) return 'audio';\n  if (lowerCased.startsWith('video')) return 'video';\n\n  return 'file';\n};\n\n/**\n * Calculates the downscaled size of an image while preserving its aspect ratio.\n *\n * @param {Object} origin - The original size object with `width` and `height` properties.\n * @param {Object} resizing - The resizing object with optional `width` and `height` properties.\n * @returns {Object} - A new size object with the downscaled `width` and `height` properties.\n * @example\n * ```ts\n *   getDownscaleSize({ width: 1200, height: 800 }, { width: 600 }); // returns { width: 600, height: 400 }\n * ```\n */\ntype Size = { width: number; height: number };\nexport function getDownscaleSize(origin: Size, resizing: Partial<Size>) {\n  let ratio: number;\n\n  const maxWidth = resizing.width || origin.width,\n    maxHeight = resizing.height || origin.height;\n\n  if (origin.width <= maxWidth && origin.height <= maxHeight) {\n    ratio = 1;\n  } else if (origin.width > maxWidth && origin.height <= maxHeight) {\n    ratio = maxWidth / origin.width;\n  } else if (origin.width <= maxWidth && origin.height > maxHeight) {\n    ratio = maxHeight / origin.height;\n  } else {\n    ratio = Math.min(maxWidth / origin.width, maxHeight / origin.height);\n  }\n\n  return { width: origin.width * ratio, height: origin.height * ratio };\n}\n\n/**\n * Normalize a file name by ensuring it has the given extension, if it doesn't already.\n *\n * @param {string} fileName - The file name to normalize.\n * @param {string} extension - The desired extension, without a leading period.\n * @returns {string} - The normalized file name, with the extension.\n */\nexport function normalizeFileName(fileName: string, extension: string) {\n  if (!extension) return fileName;\n\n  // .extension\n  let _extension = extension.toLowerCase();\n  if (_extension.indexOf('.') !== 0) {\n    _extension = '.' + _extension;\n  }\n\n  // filename.extension | filename\n  const _filename = fileName.toLowerCase();\n  const hasExtension = _filename.lastIndexOf(_extension) === _filename.length - _extension.length;\n  if (!hasExtension) {\n    // filename.extension\n    return fileName + _extension;\n  } else {\n    // filename.extension\n    return fileName;\n  }\n}\n\n/**\n * Parses a MIME type string into its components.\n *\n * @param mimeType - The MIME type string to parse.\n * @returns An object containing the type, subtype, and parameters of the MIME type.\n */\ntype MimeType = { type: string; subtype: string; parameters: Record<string, string> };\nexport function parseMimeType(mimeType: string): MimeType {\n  const [fullType, ...parts] = mimeType.split(';');\n  const [type, subtype] = fullType.split('/');\n  const parameters: MimeType['parameters'] = {};\n\n  for (const part of parts) {\n    const [name, value] = part.trim().split('=');\n    parameters[name] = value;\n  }\n\n  return { type, subtype, parameters };\n}\n\n/**\n * Returns the file extension based on the MIME type.\n *\n * @param {string | null | undefined} mimeType - The MIME type to look up.\n * @returns {string} - The file extension for the given MIME type, or an empty string if no matching file extension was found.\n */\nexport function getFileExtensionFromMime(mimeType?: string | null): string {\n  if (!mimeType) return '';\n  const MIME_EXTENSION_MAP = Object.entries(EXTENSION_MIME_MAP).reduce((acc, [key, value]) => {\n    acc[value] = key;\n    return acc;\n  }, {} as Record<string, string>);\n\n  const extension = MIME_EXTENSION_MAP[mimeType.toLowerCase()];\n  if (extension) return '.' + extension;\n  return '';\n}\n\n/**\n * Returns the MIME type based on the file extension.\n *\n * @param {string | null | undefined} ext - The file extension to look up.\n * @returns {string} - The MIME type for the given file extension, or an empty string if no matching MIME type was found.\n */\nexport function getMimeFromFileExtension(ext?: string | null) {\n  if (!ext) return '';\n\n  const sliceIdx = ext.lastIndexOf('.');\n  const extWithoutDot = sliceIdx === -1 ? ext : ext.slice(sliceIdx + 1);\n\n  return EXTENSION_MIME_MAP[extWithoutDot.toLowerCase()] || '';\n}\n\n/**\n * Returns the file extension of a file path.\n *\n * @param {string} filePath - The file path to extract the extension from.\n * @returns {string} - The file extension, or an empty string if the file path does not have an extension.\n */\nexport function getFileExtension(filePath: string) {\n  const pathWithoutParams = filePath.split('?')[0];\n\n  const idx = pathWithoutParams.lastIndexOf('.');\n  if (idx === -1) return '';\n\n  const result = pathWithoutParams.slice(idx - pathWithoutParams.length).toLowerCase();\n  if (result === '.') return '';\n  else return result;\n}\n\nexport async function getFileExtensionFromUri(uri: string) {\n  const type = await fetch(uri).then((response) => response.headers.get('content-type'));\n  return getFileExtensionFromMime(type);\n}\n\nexport function isImage(filePath: string, mimeType?: string) {\n  const type = getFileType(mimeType || getFileExtension(filePath));\n  return type === 'image';\n}\n\nexport function shouldCompressImage(mime: string, compressionEnabled = true) {\n  const extension = isJPG(mime) ? 'jpg' : getFileExtensionFromMime(mime);\n  return Boolean(extension.match(/jpg|jpeg|png/i) && compressionEnabled);\n}\n\n/**\n * https://github.com/gathertown/sendbird-uikit-react-native/pull/29\n * This function is used solely for the purpose of classifying `image/jpg`.\n *\n * We only use it to determine whether image compression is applied because `image/jpg` is not a MIME type standard.\n * Therefore, it is not reflected in `EXTENSION_MIME_MAP`, which extracts MIME types uploaded to the server. (to comply standard)\n * */\nfunction isJPG(mime: string) {\n  return mime === 'image/jpg';\n}\n"],"mappings":"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"}